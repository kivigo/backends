name: 🚀 Release

permissions:
  contents: write
  actions: write
  attestations: write
  pages: write
  id-token: write

concurrency:
  group: release-${{ github.event.inputs.backend_name }}
  cancel-in-progress: false

"on":
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.5.0). Ignored if Automatic Tag is enabled.'
        required: false
        type: string
      backend_name:
        description: 'Backend to release (e.g., badger, redis, etcd, consul, local, or "core")'
        required: true
        type: string
      automatic_tag:
        description: 'Automatically increment version and construct tag'
        required: true
        default: true
        type: boolean
      bump:
        description: 'If Automatic Tag is enabled, select which part to bump'
        required: false
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      latest:
        description: 'Also create/update the "latest" tag for this backend'
        required: true
        default: true
        type: boolean

jobs:
  discover-backends:
    name: 🔍 Discover Backends
    runs-on: ubuntu-latest
    outputs:
      backends: ${{ steps.discover.outputs.backends }}
    steps:
      - name: 🛎️ Checkout code
        uses: actions/checkout@v4

      - name: 🔍 Discover backends
        id: discover
        run: |
          backends=$(find . -mindepth 1 -maxdepth 1 -type d | sort)
          backend_list=()
          for backend in $backends; do
            if [[ -f "$backend/go.mod" ]]; then
              backend_name=$(basename "$backend")
              backend_list+=("$backend_name")
              echo "✅ Found backend: $backend_name"
            fi
          done
          backends_json=$(printf '%s\n' "${backend_list[@]}" | jq -R . | jq -s . | jq -c .)
          echo "backends=$backends_json" >> $GITHUB_OUTPUT
          echo "📦 Discovered backends: $backends_json"

  validate-inputs:
    name: 🔍 Validate Inputs
    runs-on: ubuntu-latest
    needs: discover-backends
    outputs:
      version: ${{ steps.validate.outputs.version }}
      backend_name: ${{ steps.validate.outputs.backend_name }}
      latest: ${{ steps.validate.outputs.latest }}
    steps:
      - name: 🛎️ Checkout code
        uses: actions/checkout@v4
      - name: 🔍 Validate version and backend_name
        id: validate
        run: |
          version="${{ github.event.inputs.version }}"
          backend_name="${{ github.event.inputs.backend_name }}"
          automatic_tag="${{ github.event.inputs.automatic_tag }}"
          bump="${{ github.event.inputs.bump }}"
          latest="${{ github.event.inputs.latest }}"
          backends='${{ needs.discover-backends.outputs.backends }}'

          # Check backend_name
          if [[ "$backend_name" == "core" ]]; then
            echo "✅ Releasing core"
          else
            found=$(echo "$backends" | jq -r '.[]' | grep -Fx "$backend_name" || true)
            if [[ -z "$found" ]]; then
              echo "❌ Error: Backend '$backend_name' does not exist."
              exit 1
            fi
            echo "✅ Backend to release: $backend_name"
          fi

          # Determine version
          if [[ "$automatic_tag" == "true" ]]; then
            # Find latest tag for this backend
            if [[ "$backend_name" == "core" ]]; then
              prefix="v"
              latest_tag=$(git tag --list "v*" | sort -V | tail -n1)
            else
              prefix="${backend_name}/v"
              latest_tag=$(git tag --list "${backend_name}/v*" | sed "s|^${backend_name}/||" | sort -V | tail -n1)
            fi

            if [[ -z "$latest_tag" ]]; then
              new_version="v1.0.0"
            else
              tag_version="${latest_tag#${prefix}}"
              IFS='.' read -r major minor patch <<<"${tag_version#v}"
              case "$bump" in
                major)
                  major=$((major+1)); minor=0; patch=0
                  ;;
                minor)
                  minor=$((minor+1)); patch=0
                  ;;
                patch|*)
                  patch=$((patch+1))
                  ;;
              esac
              new_version="v${major}.${minor}.${patch}"
            fi
            version="$new_version"
            echo "🔢 Automatic tag enabled. New version: $version"
          else
            # Manual version
            if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "❌ Error: Version must follow semantic versioning format (e.g., v1.5.0)"
              exit 1
            fi
            echo "🔢 Manual version: $version"
          fi

          echo "version=$version" >> $GITHUB_OUTPUT
          echo "backend_name=$backend_name" >> $GITHUB_OUTPUT
          echo "latest=$latest" >> $GITHUB_OUTPUT

  create-tag:
    name: 🏷️ Create and Push Tag(s)
    runs-on: ubuntu-latest
    needs: validate-inputs
    steps:
      - name: 🛎️ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🏷️ Create and push version tag (with existence check)
        id: tag
        run: |
          version="${{ needs.validate-inputs.outputs.version }}"
          backend_name="${{ needs.validate-inputs.outputs.backend_name }}"
          latest="${{ needs.validate-inputs.outputs.latest }}"

          if [[ "$backend_name" == "core" ]]; then
            tag="$version"
            latest_tag="latest"
          else
            tag="${backend_name}/${version}"
            latest_tag="${backend_name}/latest"
          fi

          # Check if tag already exists locally or remotely
          git fetch --tags
          if git tag -l | grep -q "^${tag}$"; then
            echo "⚠️ Tag $tag already exists locally"
            exit 1
          fi
          if git ls-remote --tags origin | grep -q "refs/tags/${tag}$"; then
            echo "⚠️ Tag $tag already exists remotely"
            exit 1
          fi

          git tag "$tag"
          echo "✅ Created tag: $tag"
          git push origin "$tag"
          echo "📤 Pushed tag: $tag"

          # Create/update latest tag if requested
          if [[ "$latest" == "true" ]]; then
            # Delete remote latest tag if exists
            if git ls-remote --tags origin | grep -q "refs/tags/${latest_tag}$"; then
              git push --delete origin "$latest_tag"
            fi
            # Delete local latest tag if exists
            if git tag -l | grep -q "^${latest_tag}$"; then
              git tag -d "$latest_tag"
            fi
            git tag "$latest_tag"
            git push origin "$latest_tag"
            echo "📤 Pushed tag: $latest_tag"
          fi